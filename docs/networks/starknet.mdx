---
title: Starknet data and filter
description: "This page contains the definition for Starknet data and filter."
priority: 60
updatedAt: 2023-01-15 10:00
---

# Starknet data and filter format

Apibara provides data streams for all Starknet networks:

**StarkNet Mainnet**

- endpoint: `https://mainnet.starknet.a5a.ch`

**StarkNet Sepolia Testnet**

- endpoint: `https://sepolia.starknet.a5a.ch`

**StarkNet GÃ¶rli Testnet** (deprecated)

- endpoint: `https://goerli.starknet.a5a.ch`

## Data and filters

Apibara streams are an efficient mechanism to stream any on-chain data directly
into your application. One way it achieves great performance is by allowing
developers to select _exactly_ the data they need.

Developers filter data included in a stream by configuring the stream with a filter.
The are many types of filters for Starknet, but they all work in the following way:

- An empty filter (that is, a filter that has no field set) matches any object (e.g. transaction or event).
- If a field is set, then it's checked by equality. An object is included if and
  only if its field is equal to the filter.
- If an array field is set, then the object's field is prefix-matched. An object is include
  if and only if its field first `n` elements (where `n` is the length of the filter's field) are equal to the
  filter.
- If a filter has multiple fields set, then it matches an object if and only if all fields match.

This guide explains how to use filters using the Apibara CLI indexers. If you're
using the Typescript SDK or Python SDK, please refer to their documentation to
learn how to build filters.

## Typescript support

Starknet types are included in the `@apibara/indexer` package, under the `starknet` module. After [setting up your project to use Typescript](/docs/getting-started/typescript-support), import the types and you will get autocomplete working in your editor:

```ts
import type { Block, Filter } from "https://esm.sh/@apibara/indexer/starknet";
```

The `FieldElement` type is defined as `0x${string}`, that it a `0x`-prefixed hex string.

## Filtering data

Apibara supports _any_ onchain data and it's not limited to events.

```ts
export type Filter = {
  /** Header information. */
  header?: HeaderFilter;
  /** Include transactions. */
  transactions?: TransactionFilter[];
  /** Include events. */
  events?: EventFilter[];
  /** Include messages from L2 to L1. */
  messages?: L2ToL1MessageFilter[];
  /** Include state updates. */
  stateUpdate?: StateUpdateFilter;
};
```

### Header

Block headers contain information about the block being processed. The `weak` flag is used to receive headers only if any other filter matches, this way your indexer won't have to process empty blocks.

```ts
export type HeaderFilter = {
  /* If true, only include headers if any other filter matches. */
  weak?: boolean;
};
```

### Events

Events are the most common filter used by Apibara users. You can filter by smart contract or event selector.

- Compute the selector by computing the hash of the event name. That will be the first element of your `keys`.
- If you need multiple event types (e.g. `Approve` and `Transfer`), simply add more event filters to `filter.events`.
- Set `includeReceipt: false` to speed up indexing significantly.

**Common patterns**

- All events from a specific smart contract.

```ts
const filter = {
  events: [{ fromAddress: MY_CONTRACT, includeReceipt: false }],
};
```

- Multiple events from the same smart contract.

```ts
const filter = {
  events: [
    {
      fromAddress: MY_CONTRACT,
      keys: [APPROVE_SELECTOR],
      includeReceipt: false,
    },
    {
      fromAddress: MY_CONTRACT,
      keys: [TRANSFER_SELECTOR],
      includeReceipt: false,
    },
  ],
};
```

- Multiple events from different smart contracts.

```ts
const filter = {
  events: [
    {
      fromAddress: CONTRACT_A,
      keys: [TRANSFER_SELECTOR],
      includeReceipt: false,
    },
    {
      fromAddress: CONTRACT_B,
      keys: [TRANSFER_SELECTOR],
      includeReceipt: false,
    },
    {
      fromAddress: CONTRACT_C,
      keys: [TRANSFER_SELECTOR],
      includeReceipt: false,
    },
  ],
};
```

The full `EventFilter` type is the following.

```ts
export type EventFilter = {
  /** Filter by contract address. */
  fromAddress?: FieldElement;
  /** Filter by event keys (selector). */
  keys?: FieldElement[];
  /** Filter by event data. */
  data?: FieldElement[];
  /** Include events from reverted transactions. */
  includeReverted?: boolean;
  /** Include the transaction that emitted the event. Defaults to true. */
  includeTransaction?: boolean;
  /** Include the receipt of the transaction that emitted the event. Defaults to true. */
  includeReceipt?: boolean;
};
```

### Transactions

Transactions on Starknet can be of different type (invoke, declare contract, deploy contract or account, handle L1 message).

**Common patterns**

- Request all transactions in a block. Notice the empty transaction filter object, this filter will match _any_ transaction.

```ts
const filter = { transactions: [{}] };
```

- Request all transactions of a specific type, e.g. deploy account. In this case we specify the `deployAccount` variant.

```ts
const filter = { transactions: [{ deployAccount: {} }] };
```

The type definitions for `TransactionFilter` are:

```ts
export type TransactionFilterCommon = {
  /*** Include reverted transactions. */
  includeReverted?: boolean;
};

// TODO: add a `OneOf<T1, T2, T3, ..>` to enforce this pattern.

export type InvokeTransactionV0Filter = {
  invokeV0?: {
    /** Filter by contract address. */
    contractAddress?: FieldElement;
    /** Filter by function selector. */
    entryPointSelector?: FieldElement;
    /** Filter by function arguments. */
    calldata?: FieldElement[];
  };
  invokeV1?: never;
  deploy?: never;
  declare?: never;
  l1Handler?: never;
  deployAccount?: never;
};

export type InvokeTransactionV1Filter = {
  invokeV1?: {
    /** Filter by sender address. */
    senderAddress?: FieldElement;
    /** Filter by function arguments. */
    calldata?: FieldElement[];
  };
  invokeV0?: never;
  deploy?: never;
  declare?: never;
  l1Handler?: never;
  deployAccount?: never;
};

export type DeployTransactionFilter = {
  deploy?: {
    /** Filter by contract address salt. */
    contractAddressSalt?: FieldElement;
    /** Filter by class hash. */
    classHash?: FieldElement;
    /** Filter by constructor arguments. */
    constructorCalldata?: FieldElement[];
  };
  invokeV0?: never;
  invokeV1?: never;
  declare?: never;
  l1Handler?: never;
  deployAccount?: never;
};

export type DeclareTransactionFilter = {
  declare?: {
    /** Filter by class hash. */
    classHash?: FieldElement;
    /** Filter by sender address. */
    senderAddress?: FieldElement;
  };
  invokeV0?: never;
  invokeV1?: never;
  deploy?: never;
  l1Handler?: never;
  deployAccount?: never;
};

export type L1HandlerTransactionFilter = {
  l1Handler?: {
    /** Filter by contract address. */
    contractAddress?: FieldElement;
    /** Filter by function selector. */
    entryPointSelector?: FieldElement;
    /** Filter by function arguments. */
    calldata?: FieldElement[];
  };
  invokeV0?: never;
  invokeV1?: never;
  deploy?: never;
  declare?: never;
  deployAccount?: never;
};

export type DeployAccountTransactionFilter = {
  deployAccount?: {
    /** Filter by contract address salt. */
    contractAddressSalt?: FieldElement;
    /** Filter by class hash. */
    classHash?: FieldElement;
    /** Filter by constructor arguments. */
    constructorCalldata?: FieldElement[];
  };
  invokeV0?: never;
  invokeV1?: never;
  deploy?: never;
  declare?: never;
  l1Handler?: never;
};

export type TransactionFilter = TransactionFilterCommon &
  (
    | InvokeTransactionV0Filter
    | InvokeTransactionV1Filter
    | DeployTransactionFilter
    | DeclareTransactionFilter
    | L1HandlerTransactionFilter
    | DeployAccountTransactionFilter
  );

export type EventFilter = {
  /** Filter by contract address. */
  fromAddress?: FieldElement;
  /** Filter by event keys (selector). */
  keys?: FieldElement[];
  /** Filter by event data. */
  data?: FieldElement[];
  /** Include events from reverted transactions. */
  includeReverted?: boolean;
  /** Include the transaction that emitted the event. Defaults to true. */
  includeTransaction?: boolean;
  /** Include the receipt of the transaction that emitted the event. Defaults to true. */
  includeReceipt?: boolean;
};
```

### Messages

Filter messages from L1 to Starknet.

```ts
export type L2ToL1MessageFilter = {
  /** Filter by destination address. */
  toAddress?: FieldElement;
  /** Filter by payload. */
  payload?: FieldElement[];
  /** Include messages from reverted transactions. */
  includeReverted?: boolean;
};
```

### State update

This filter returns data about updates to Starknet state. Developers usually use this filter to track changes to the storage variables (`storageDiffs`) or declared/deployed contracts.

```ts
export type StateUpdateFilter = {
  /** Filter storage diffs. */
  storageDiffs?: StorageDiffFilter[];
  /** Filter declared contracts. */
  declaredContracts?: DeclaredContractFilter[];
  /** Filter deployed contracts. */
  deployedContracts?: DeployedContractFilter[];
  /** Filter nonce updates. */
  nonces?: NonceUpdateFilter[];
  /** Filter declared classes. */
  declaredClasses?: DeclaredClassFilter[];
  /** Filter replaced classes. */
  replacedClasses?: ReplacedClassFilter[];
};

export type StorageDiffFilter = {
  /** Filter by contract address. */
  contractAddress?: FieldElement;
};

export type DeclaredContractFilter = {
  /** Filter by class hash. */
  classHash?: FieldElement;
};

export type DeployedContractFilter = {
  /** Filter by contract address. */
  contractAddress?: FieldElement;
  /** Filter by class hash. */
  classHash?: FieldElement;
};

export type NonceUpdateFilter = {
  /** Filter by contract address. */
  contractAddress?: FieldElement;
  /** Filter by nonce value. */
  nonce?: FieldElement;
};

export type DeclaredClassFilter = {
  /** Filter by class hash. */
  classHash?: FieldElement;
  /** Filter by compiled class hash. */
  compiledClassHash?: FieldElement;
};

export type ReplacedClassFilter = {
  /** Filter by contract address. */
  contractAddress?: FieldElement;
  /** Filter by class hash. */
  classHash?: FieldElement;
};
```

## Block data

All data matching the filter is grouped together into a `Block`. Your indexer will take each block as input and transform it into the data sent to the target integration.

```ts
import type { Block } from "https://esm.sh/@apibara/indexer/starknet";

export default function transform({ header, events }: Block) {
  // do something
}
```
